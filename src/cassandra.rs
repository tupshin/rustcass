extern crate libc;
use libc::size_t;

/* automatically generated by rust-bindgen */

pub type cass_bool_t = ::libc::c_uint;
pub static cass_false: ::libc::c_uint = 0;
pub static cass_true: ::libc::c_uint = 1;
pub type cass_float_t = ::libc::c_float;
pub type cass_double_t = ::libc::c_double;
pub type cass_int8_t = ::libc::c_char;
pub type cass_uint8_t = ::libc::c_uchar;
pub type cass_int16_t = ::libc::c_short;
pub type cass_uint16_t = ::libc::c_ushort;
pub type cass_int32_t = ::libc::c_int;
pub type cass_uint32_t = ::libc::c_uint;
pub type cass_int64_t = ::libc::c_long;
pub type cass_uint64_t = ::libc::c_ulong;
pub type cass_size_t = size_t;
pub type cass_byte_t = cass_uint8_t;
pub type cass_duration_t = cass_uint64_t;
#[repr(C)]
pub struct Struct_CassBytes_ {
    pub data: *const cass_byte_t,
    pub size: cass_size_t,
}
pub type CassBytes = Struct_CassBytes_;
#[repr(C)]
pub struct Struct_CassString_ {
    pub data: *const ::libc::c_char,
    pub length: cass_size_t,
}
pub type CassString = Struct_CassString_;
#[repr(C)]
pub struct Struct_CassInet_ {
    pub address: [cass_uint8_t, ..16u],
    pub address_length: cass_uint8_t,
}
pub type CassInet = Struct_CassInet_;
#[repr(C)]
pub struct Struct_CassDecimal_ {
    pub scale: cass_int32_t,
    pub varint: CassBytes,
}
pub type CassDecimal = Struct_CassDecimal_;
pub type CassUuid = [cass_uint8_t, ..16u];
pub enum Struct_CassCluster_ { }
pub type CassCluster = Struct_CassCluster_;
pub enum Struct_CassSession_ { }
pub type CassSession = Struct_CassSession_;
pub enum Struct_CassStatement_ { }
pub type CassStatement = Struct_CassStatement_;
pub enum Struct_CassBatch_ { }
pub type CassBatch = Struct_CassBatch_;
pub enum Struct_CassFuture_ { }
pub type CassFuture = Struct_CassFuture_;
pub enum Struct_CassPrepared_ { }
pub type CassPrepared = Struct_CassPrepared_;
pub enum Struct_CassResult_ { }
pub type CassResult = Struct_CassResult_;
pub enum Struct_CassIterator_ { }
pub type CassIterator = Struct_CassIterator_;
pub enum Struct_CassRow_ { }
pub type CassRow = Struct_CassRow_;
pub enum Struct_CassValue_ { }
pub type CassValue = Struct_CassValue_;
pub enum Struct_CassCollection_ { }
pub type CassCollection = Struct_CassCollection_;
pub type Enum_CassConsistency_ = ::libc::c_uint;
pub static CASS_CONSISTENCY_ANY: ::libc::c_uint = 0;
pub static CASS_CONSISTENCY_ONE: ::libc::c_uint = 1;
pub static CASS_CONSISTENCY_TWO: ::libc::c_uint = 2;
pub static CASS_CONSISTENCY_THREE: ::libc::c_uint = 3;
pub static CASS_CONSISTENCY_QUORUM: ::libc::c_uint = 4;
pub static CASS_CONSISTENCY_ALL: ::libc::c_uint = 5;
pub static CASS_CONSISTENCY_LOCAL_QUORUM: ::libc::c_uint = 6;
pub static CASS_CONSISTENCY_EACH_QUORUM: ::libc::c_uint = 7;
pub static CASS_CONSISTENCY_SERIAL: ::libc::c_uint = 8;
pub static CASS_CONSISTENCY_LOCAL_SERIAL: ::libc::c_uint = 9;
pub static CASS_CONSISTENCY_LOCAL_ONE: ::libc::c_uint = 10;
pub type CassConsistency = Enum_CassConsistency_;
pub type Enum_CassValueType_ = ::libc::c_uint;
pub static CASS_VALUE_TYPE_UNKNOWN: ::libc::c_uint = 65535;
pub static CASS_VALUE_TYPE_CUSTOM: ::libc::c_uint = 0;
pub static CASS_VALUE_TYPE_ASCII: ::libc::c_uint = 1;
pub static CASS_VALUE_TYPE_BIGINT: ::libc::c_uint = 2;
pub static CASS_VALUE_TYPE_BLOB: ::libc::c_uint = 3;
pub static CASS_VALUE_TYPE_BOOLEAN: ::libc::c_uint = 4;
pub static CASS_VALUE_TYPE_COUNTER: ::libc::c_uint = 5;
pub static CASS_VALUE_TYPE_DECIMAL: ::libc::c_uint = 6;
pub static CASS_VALUE_TYPE_DOUBLE: ::libc::c_uint = 7;
pub static CASS_VALUE_TYPE_FLOAT: ::libc::c_uint = 8;
pub static CASS_VALUE_TYPE_INT: ::libc::c_uint = 9;
pub static CASS_VALUE_TYPE_TEXT: ::libc::c_uint = 10;
pub static CASS_VALUE_TYPE_TIMESTAMP: ::libc::c_uint = 11;
pub static CASS_VALUE_TYPE_UUID: ::libc::c_uint = 12;
pub static CASS_VALUE_TYPE_VARCHAR: ::libc::c_uint = 13;
pub static CASS_VALUE_TYPE_VARINT: ::libc::c_uint = 14;
pub static CASS_VALUE_TYPE_TIMEUUID: ::libc::c_uint = 15;
pub static CASS_VALUE_TYPE_INET: ::libc::c_uint = 16;
pub static CASS_VALUE_TYPE_LIST: ::libc::c_uint = 32;
pub static CASS_VALUE_TYPE_MAP: ::libc::c_uint = 33;
pub static CASS_VALUE_TYPE_SET: ::libc::c_uint = 34;
pub type CassValueType = Enum_CassValueType_;
pub type Enum_CassBatchType_ = ::libc::c_uint;
pub static CASS_BATCH_TYPE_LOGGED: ::libc::c_uint = 0;
pub static CASS_BATCH_TYPE_UNLOGGED: ::libc::c_uint = 1;
pub static CASS_BATCH_TYPE_COUNTER: ::libc::c_uint = 2;
pub type CassBatchType = Enum_CassBatchType_;
pub type Enum_CassCompression_ = ::libc::c_uint;
pub static CASS_COMPRESSION_NONE: ::libc::c_uint = 0;
pub static CASS_COMPRESSION_SNAPPY: ::libc::c_uint = 1;
pub static CASS_COMPRESSION_LZ4: ::libc::c_uint = 2;
pub type CassCompression = Enum_CassCompression_;
pub type Enum_CassOption_ = ::libc::c_uint;
pub static CASS_OPTION_PORT: ::libc::c_uint = 0;
pub static CASS_OPTION_CQL_VERSION: ::libc::c_uint = 1;
pub static CASS_OPTION_NUM_THREADS_IO: ::libc::c_uint = 2;
pub static CASS_OPTION_QUEUE_SIZE_IO: ::libc::c_uint = 3;
pub static CASS_OPTION_QUEUE_SIZE_EVENTS: ::libc::c_uint = 4;
pub static CASS_OPTION_CONTACT_POINTS: ::libc::c_uint = 5;
pub static CASS_OPTION_CORE_CONNECTIONS_PER_HOST: ::libc::c_uint = 6;
pub static CASS_OPTION_MAX_CONNECTIONS_PER_HOST: ::libc::c_uint = 7;
pub static CASS_OPTION_MAX_SIMULTANEOUS_CREATION: ::libc::c_uint = 8;
pub static CASS_RECONNECT_WAIT_TIME: ::libc::c_uint = 9;
pub static CASS_OPTION_CONNECT_TIMEOUT: ::libc::c_uint = 10;
pub static CASS_OPTION_WRITE_TIMEOUT: ::libc::c_uint = 11;
pub static CASS_OPTION_READ_TIMEOUT: ::libc::c_uint = 12;
pub static CASS_OPTION_LOG_LEVEL: ::libc::c_uint = 13;
pub static CASS_OPTION_LOG_DATA: ::libc::c_uint = 14;
pub static CASS_OPTION_LOG_CALLBACK: ::libc::c_uint = 15;
pub type CassOption = Enum_CassOption_;
pub type Enum_CassLogLevel_ = ::libc::c_uint;
pub static CASS_LOG_DISABLED: ::libc::c_uint = 0;
pub static CASS_LOG_CRITICAL: ::libc::c_uint = 1;
pub static CASS_LOG_ERROR: ::libc::c_uint = 2;
pub static CASS_LOG_WARN: ::libc::c_uint = 3;
pub static CASS_LOG_INFO: ::libc::c_uint = 4;
pub static CASS_LOG_DEBUG: ::libc::c_uint = 5;
pub static CASS_LOG_LAST_ENTRY: ::libc::c_uint = 6;
pub type CassLogLevel = Enum_CassLogLevel_;
pub type Enum_CassErrorSource_ = ::libc::c_uint;
pub static CASS_ERROR_SOURCE_NONE: ::libc::c_uint = 0;
pub static CASS_ERROR_SOURCE_LIB: ::libc::c_uint = 1;
pub static CASS_ERROR_SOURCE_SERVER: ::libc::c_uint = 2;
pub static CASS_ERROR_SOURCE_SSL: ::libc::c_uint = 3;
pub static CASS_ERROR_SOURCE_COMPRESSION: ::libc::c_uint = 4;
pub type CassErrorSource = Enum_CassErrorSource_;
pub type Enum_CassError_ = ::libc::c_uint;
pub static CASS_OK: ::libc::c_uint = 0;
pub static CASS_ERROR_LIB_BAD_PARAMS: ::libc::c_uint = 16777217;
pub static CASS_ERROR_LIB_INVALID_OPTION: ::libc::c_uint = 16777218;
pub static CASS_ERROR_LIB_INVALID_OPTION_SIZE: ::libc::c_uint = 16777219;
pub static CASS_ERROR_LIB_NO_STREAMS: ::libc::c_uint = 16777220;
pub static CASS_ERROR_LIB_UNABLE_TO_INIT: ::libc::c_uint = 16777221;
pub static CASS_ERROR_LIB_MESSAGE_PREPARE: ::libc::c_uint = 16777222;
pub static CASS_ERROR_LIB_HOST_RESOLUTION: ::libc::c_uint = 16777223;
pub static CASS_ERROR_LIB_UNEXPECTED_RESPONSE: ::libc::c_uint = 16777224;
pub static CASS_ERROR_LIB_REQUEST_QUEUE_FULL: ::libc::c_uint = 16777225;
pub static CASS_ERROR_LIB_NO_AVAILABLE_IO_THREAD: ::libc::c_uint = 16777226;
pub static CASS_ERROR_LIB_WRITE_ERROR: ::libc::c_uint = 16777227;
pub static CASS_ERROR_LIB_NO_HOSTS_AVAILABLE: ::libc::c_uint = 16777228;
pub static CASS_ERROR_LIB_INDEX_OUT_OF_BOUNDS: ::libc::c_uint = 16777229;
pub static CASS_ERROR_LIB_INVALID_ITEM_COUNT: ::libc::c_uint = 16777230;
pub static CASS_ERROR_LIB_INVALID_VALUE_TYPE: ::libc::c_uint = 16777231;
pub static CASS_ERROR_LIB_REQUEST_TIMED_OUT: ::libc::c_uint = 16777232;
pub static CASS_ERROR_UNABLE_TO_SET_KEYSPACE: ::libc::c_uint = 16777233;
pub static CASS_ERROR_SERVER_SERVER_ERROR: ::libc::c_uint = 33554432;
pub static CASS_ERROR_SERVER_PROTOCOL_ERROR: ::libc::c_uint = 33554442;
pub static CASS_ERROR_SERVER_BAD_CREDENTIALS: ::libc::c_uint = 33554688;
pub static CASS_ERROR_SERVER_UNAVAILABLE: ::libc::c_uint = 33558528;
pub static CASS_ERROR_SERVER_OVERLOADED: ::libc::c_uint = 33558529;
pub static CASS_ERROR_SERVER_IS_BOOTSTRAPPING: ::libc::c_uint = 33558530;
pub static CASS_ERROR_SERVER_TRUNCATE_ERROR: ::libc::c_uint = 33558531;
pub static CASS_ERROR_SERVER_WRITE_TIMEOUT: ::libc::c_uint = 33558784;
pub static CASS_ERROR_SERVER_READ_TIMEOUT: ::libc::c_uint = 33559040;
pub static CASS_ERROR_SERVER_SYNTAX_ERROR: ::libc::c_uint = 33562624;
pub static CASS_ERROR_SERVER_UNAUTHORIZED: ::libc::c_uint = 33562880;
pub static CASS_ERROR_SERVER_INVALID_QUERY: ::libc::c_uint = 33563136;
pub static CASS_ERROR_SERVER_CONFIG_ERROR: ::libc::c_uint = 33563392;
pub static CASS_ERROR_SERVER_ALREADY_EXISTS: ::libc::c_uint = 33563648;
pub static CASS_ERROR_SERVER_UNPREPARED: ::libc::c_uint = 33563904;
pub static CASS_ERROR_SSL_CERT: ::libc::c_uint = 50331649;
pub static CASS_ERROR_SSL_CA_CERT: ::libc::c_uint = 50331650;
pub static CASS_ERROR_SSL_PRIVATE_KEY: ::libc::c_uint = 50331651;
pub static CASS_ERROR_SSL_CRL: ::libc::c_uint = 50331652;
pub static CASS_ERROR_LAST_ENTRY: ::libc::c_uint = 50331653;
pub type CassError = Enum_CassError_;
pub type CassLogCallback =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut ::libc::c_void, arg2: cass_uint64_t,
                               arg3: CassLogLevel, arg4: CassString)>;
#[link(name = "cassandra")]
extern "C" {
    pub fn cass_cluster_new() -> *mut CassCluster;
    pub fn cass_cluster_setopt(cluster: *mut CassCluster, option: CassOption,
                               data: *const ::libc::c_void,
                               data_length: cass_size_t) -> CassError;
    pub fn cass_cluster_getopt(cluster: *const CassCluster,
                               option: CassOption, data: *mut ::libc::c_void,
                               data_length: *mut cass_size_t) -> CassError;
    pub fn cass_cluster_connect(cluster: *mut CassCluster) -> *mut CassFuture;
    pub fn cass_cluster_connect_keyspace(cluster: *mut CassCluster,
                                         keyspace: *const ::libc::c_char) ->
     *mut CassFuture;
    pub fn cass_cluster_free(cluster: *mut CassCluster);
    pub fn cass_session_close(session: *mut CassSession) -> *mut CassFuture;
    pub fn cass_session_prepare(session: *mut CassSession,
                                statement: CassString) -> *mut CassFuture;
    pub fn cass_session_execute(session: *mut CassSession,
                                statement: *mut CassStatement) ->
     *mut CassFuture;
    pub fn cass_session_execute_batch(session: *mut CassSession,
                                      batch: *mut CassBatch) ->
     *mut CassFuture;
    pub fn cass_future_free(future: *mut CassFuture);
    pub fn cass_future_ready(future: *mut CassFuture) -> cass_bool_t;
    pub fn cass_future_wait(future: *mut CassFuture);
    pub fn cass_future_wait_timed(future: *mut CassFuture,
                                  timeout: cass_duration_t) -> cass_bool_t;
    pub fn cass_future_get_session(future: *mut CassFuture) ->
     *mut CassSession;
    pub fn cass_future_get_result(future: *mut CassFuture) ->
     *const CassResult;
    pub fn cass_future_get_prepared(future: *mut CassFuture) ->
     *const CassPrepared;
    pub fn cass_future_error_code(future: *mut CassFuture) -> CassError;
    pub fn cass_future_error_message(future: *mut CassFuture) -> CassString;
    pub fn cass_statement_new(statement: CassString,
                              parameter_count: cass_size_t,
                              consistency: CassConsistency) ->
     *mut CassStatement;
    pub fn cass_statement_free(statement: *mut CassStatement);
    pub fn cass_statement_bind_null(statement: *mut CassStatement,
                                    index: cass_size_t) -> CassError;
    pub fn cass_statement_bind_int32(statement: *mut CassStatement,
                                     index: cass_size_t, value: cass_int32_t)
     -> CassError;
    pub fn cass_statement_bind_int64(statement: *mut CassStatement,
                                     index: cass_size_t, value: cass_int64_t)
     -> CassError;
    pub fn cass_statement_bind_float(statement: *mut CassStatement,
                                     index: cass_size_t, value: cass_float_t)
     -> CassError;
    pub fn cass_statement_bind_double(statement: *mut CassStatement,
                                      index: cass_size_t,
                                      value: cass_double_t) -> CassError;
    pub fn cass_statement_bind_bool(statement: *mut CassStatement,
                                    index: cass_size_t, value: cass_bool_t) ->
     CassError;
    pub fn cass_statement_bind_string(statement: *mut CassStatement,
                                      index: cass_size_t, value: CassString)
     -> CassError;
    pub fn cass_statement_bind_bytes(statement: *mut CassStatement,
                                     index: cass_size_t, value: CassBytes) ->
     CassError;
    pub fn cass_statement_bind_uuid(statement: *mut CassStatement,
                                    index: cass_size_t, value: CassUuid) ->
     CassError;
    pub fn cass_statement_bind_inet(statement: *mut CassStatement,
                                    index: cass_size_t, value: CassInet) ->
     CassError;
    pub fn cass_statement_bind_decimal(statement: *mut CassStatement,
                                       index: cass_size_t, value: CassDecimal)
     -> CassError;
    pub fn cass_statement_bind_custom(statement: *mut CassStatement,
                                      index: cass_size_t, size: cass_size_t,
                                      output: *mut *mut cass_byte_t) ->
     CassError;
    pub fn cass_statement_bind_collection(statement: *mut CassStatement,
                                          index: cass_size_t,
                                          collection: *const CassCollection,
                                          is_map: cass_bool_t) -> CassError;
    pub fn cass_prepared_free(prepared: *const CassPrepared);
    pub fn cass_prepared_bind(prepared: *const CassPrepared,
                              parameter_count: cass_size_t,
                              consistency: CassConsistency) ->
     *mut CassStatement;
    pub fn cass_batch_new(consistency: CassConsistency, _type: CassBatchType)
     -> *mut CassBatch;
    pub fn cass_batch_free(batch: *mut CassBatch);
    pub fn cass_batch_add_statement(batch: *mut CassBatch,
                                    statement: *mut CassStatement) ->
     CassError;
    pub fn cass_collection_new(item_count: cass_size_t) ->
     *mut CassCollection;
    pub fn cass_collection_free(collection: *mut CassCollection);
    pub fn cass_collection_append_int32(collection: *mut CassCollection,
                                        value: cass_int32_t) -> CassError;
    pub fn cass_collection_append_int64(collection: *mut CassCollection,
                                        value: cass_int64_t) -> CassError;
    pub fn cass_collection_append_float(collection: *mut CassCollection,
                                        value: cass_float_t) -> CassError;
    pub fn cass_collection_append_double(collection: *mut CassCollection,
                                         value: cass_double_t) -> CassError;
    pub fn cass_collection_append_bool(collection: *mut CassCollection,
                                       value: cass_bool_t) -> CassError;
    pub fn cass_collection_append_string(collection: *mut CassCollection,
                                         value: CassString) -> CassError;
    pub fn cass_collection_append_bytes(collection: *mut CassCollection,
                                        value: CassBytes) -> CassError;
    pub fn cass_collection_append_uuid(collection: *mut CassCollection,
                                       value: CassUuid) -> CassError;
    pub fn cass_collection_append_inet(collection: *mut CassCollection,
                                       value: CassInet) -> CassError;
    pub fn cass_collection_append_decimal(collection: *mut CassCollection,
                                          value: CassDecimal) -> CassError;
    pub fn cass_result_free(result: *const CassResult);
    pub fn cass_result_row_count(result: *const CassResult) -> cass_size_t;
    pub fn cass_result_column_count(result: *const CassResult) -> cass_size_t;
    pub fn cass_result_column_name(result: *const CassResult,
                                   index: cass_size_t) -> CassString;
    pub fn cass_result_column_type(result: *const CassResult,
                                   index: cass_size_t) -> CassValueType;
    pub fn cass_result_first_row(result: *const CassResult) -> *const CassRow;
    pub fn cass_iterator_from_result(result: *const CassResult) ->
     *mut CassIterator;
    pub fn cass_iterator_from_row(row: *const CassRow) -> *mut CassIterator;
    pub fn cass_iterator_from_collection(value: *const CassValue) ->
     *mut CassIterator;
    pub fn cass_iterator_free(iterator: *mut CassIterator);
    pub fn cass_iterator_next(iterator: *mut CassIterator) -> cass_bool_t;
    pub fn cass_iterator_get_row(iterator: *mut CassIterator) ->
     *const CassRow;
    pub fn cass_iterator_get_column(iterator: *mut CassIterator) ->
     *const CassValue;
    pub fn cass_iterator_get_value(iterator: *mut CassIterator) ->
     *const CassValue;
    pub fn cass_row_get_column(row: *const CassRow, index: cass_size_t) ->
     *const CassValue;
    pub fn cass_value_get_int32(value: *const CassValue,
                                output: *mut cass_int32_t) -> CassError;
    pub fn cass_value_get_int64(value: *const CassValue,
                                output: *mut cass_int64_t) -> CassError;
    pub fn cass_value_get_float(value: *const CassValue,
                                output: *mut cass_float_t) -> CassError;
    pub fn cass_value_get_double(value: *const CassValue,
                                 output: *mut cass_double_t) -> CassError;
    pub fn cass_value_get_bool(value: *const CassValue,
                               output: *mut cass_bool_t) -> CassError;
    pub fn cass_value_get_uuid(value: *const CassValue, output: CassUuid) ->
     CassError;
    pub fn cass_value_get_inet(value: *const CassValue, output: *mut CassInet)
     -> CassError;
    pub fn cass_value_get_string(value: *const CassValue,
                                 output: *mut CassString) -> CassError;
    pub fn cass_value_get_bytes(value: *const CassValue,
                                output: *mut CassBytes) -> CassError;
    pub fn cass_value_get_decimal(value: *const CassValue,
                                  output: *mut CassDecimal) -> CassError;
    pub fn cass_value_type(value: *const CassValue) -> CassValueType;
    pub fn cass_value_is_null(value: *const CassValue) -> cass_bool_t;
    pub fn cass_value_is_collection(value: *const CassValue) -> cass_bool_t;
    pub fn cass_value_item_count(collection: *const CassValue) -> cass_size_t;
    pub fn cass_value_primary_sub_type(collection: *const CassValue) ->
     CassValueType;
    pub fn cass_value_secondary_sub_type(collection: *const CassValue) ->
     CassValueType;
    pub fn cass_uuid_generate_time(output: CassUuid);
    pub fn cass_uuid_from_time(time: cass_uint64_t, output: CassUuid);
    pub fn cass_uuid_min_from_time(time: cass_uint64_t, output: CassUuid);
    pub fn cass_uuid_max_from_time(time: cass_uint64_t, output: CassUuid);
    pub fn cass_uuid_generate_random(output: CassUuid);
    pub fn cass_uuid_timestamp(uuid: CassUuid) -> cass_uint64_t;
    pub fn cass_uuid_version(uuid: CassUuid) -> cass_uint8_t;
    pub fn cass_uuid_string(uuid: CassUuid, output: *mut ::libc::c_char);
    pub fn cass_error_desc(error: CassError) -> *const ::libc::c_char;
    pub fn cass_log_level_string(log_level: CassLogLevel) ->
     *const ::libc::c_char;
    pub fn cass_inet_init_v4(address: *const cass_uint8_t) -> CassInet;
    pub fn cass_inet_init_v6(address: *const cass_uint8_t) -> CassInet;
    pub fn cass_decimal_init(scale: cass_int32_t, varint: CassBytes) ->
     CassDecimal;
    pub fn cass_bytes_init(data: *const cass_byte_t, size: cass_size_t) ->
     CassBytes;
    pub fn cass_string_init(null_terminated: *const ::libc::c_char) ->
     CassString;
    pub fn cass_string_init2(data: *const ::libc::c_char, length: cass_size_t)
     -> CassString;
}
